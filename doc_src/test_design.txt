<!--VARIABLES {"title": "Тест дизайн", "SORT_ORDER": "32"}-->

[TOC]

----------------------------------------------------------------------------------------------------
## Тест - дизайн

<!--i ["тест - дизайн"]-->
**Тест - дизайн** — это процесс создания тестов. Каждый тест предназначен для проверки определенного 
 предположения. 

Задача специалиста — найти баланс и выявить максимальное количество ошибок при необходимом минимуме 
тестовых сценариев. При этом нужно проверить все наиболее важные кейсы, поскольку время тестирования 
ограничено.
Техники тест-дизайна: 

- Классы эквивалентности;
- Граничные значения;
- Попарное тестирование;
- Причина и следствие;
- Таблица принятия решений;
- Предугадывание ошибок.

Предугадывание ошибок — это способ предотвращения ошибок, дефектов и отказов, основанный на знаниях 
тестировщика, включающих:

- Историю работы приложения в прошлом;
- Наиболее вероятные типы дефектов, допускаемых при разработке;
- Типы дефектов, которые были обнаружены в схожих приложениях.
Эта техника всегда идет в комбинации с какой-то другой (только пользуясь предугадыванием 
качественного тестирования не будет), а также с большим опытом тестировщика плюс отличное знание 
тестируемого продукта. 

**Классы эквивалентности** — это разделение функциональности системы или обрабатываемых  данных на 
определенные группы значений (диапазоны), с которыми тестируемое приложение должно обрабатывать 
данные одинаково.
Мы будем рассматривать минимальное количество проверок, исключая большое количество негативных и 
расширенных (например, дробный возраст и т.д.). 

**Граничные значения** — это значения, в которых один класс эквивалентности переходит в другой 
диапазон.
Путем долгого наблюдения за разработкой и анализа багов, специалисты пришли к выводу, что 
большинство ошибок возникает именно на границах между классами эквивалентности. То есть нам, в 
первую очередь, важно проверить переходы на стыке границ каждого класса, так как именно там велик 
риск возникновения ошибок.

На каждой границе диапазона следует проверить по три значения:
- граничное;
- шаг внутрь границ;
- шаг за границы.
В итоге благодаря технике тест-дизайна классы эквивалентности и граничные значения мы получаем 
вместо 100+ проверок всего 10. 

## Попарное тестирование

<!--i ["Попарное тестирование"]-->
**Попарное тестирование** (`Pairwise Testing`) — техника тест-дизайна, при которой тестовые сценарии 
разрабатываются таким образом, чтобы выполнить все возможные отдельные комбинации каждой пары 
входных параметров.

Данная техника тест-дизайна нужна, чтобы сразу продумать, что и как проверять, а потом тратить 
намного меньше времени на исполнение и поиск багов, сокращать общее количество тест-кейсов, тем 
самым уменьшая время и расходы, затраченные на тестирование.

Этот метод был придуман после многих лет наблюдений за багами, так сказать. Было замечено, что 
большинство дефектов вызвано взаимодействием не более двух факторов (дефекты, которые возникают при 
взаимодействии трех и более факторов, как правило, менее критичны) и нет никакого смысла проверять 
все возможные комбинации значений для всех факторов. Поэтому создается подмножество комбинаций, 
чтобы удовлетворить все факторы.

Метод попарного тестирования очень полезен при разработке тестов для приложений, включающих 
несколько параметров. Тесты разработаны таким образом, что для каждой пары входных параметров 
системы существуют всевозможные комбинации этих параметров. Набор тестов охватывает все комбинации 
не является исчерпывающим, но очень эффективен для поиска ошибок.

Рассмотрим попарное тестирование на примере приложения «Музыка», которое:

- работает на iOS и Android;
- имеет два режима громкости: «Низкая» и «Высокая»;
- имеет две скорости воспроизведения: «Нормальная» и «Ускоренная».

https://sourceforge.net/projects/vptag/    бесплатный инструмент попарного тестирования

https://github.com/microsoft/pict    Попарное независимое комбинаторное тестирование от Microsoft Corp

https://www.pairwise.org/tools     представлены все инструменты, которые помогут качественно и 
быстро создать тест-кейсы из большого количества параметров. 

## Причина и следствие

<!--i ["Причина и следствие"]-->
Давайте разберем технику тест-дизайна для проверки базовых действий и их результата. Например, если 
нажать кнопку «Зарегистрироваться» (`причина`), пользователь регистрируется в системе (`следствие`). 
Если нажать кнопку «Очистить корзину» (`причина`), то корзина с товарами становится пустой 
(`следствие`) и т.д. 

Этот метод позволяет проверить все возможности системы, а также обнаружить баги и улучшить 
техническую документацию продукта.

Алгоритм использования техники «Причина и следствие» :  

- Изучение документации и требований;
- Выделение причин и следствий, связанных с этими требованиями или эмпирическим опытом (т.е. данные 
  требования отсутствуют в документации, но вы точно знаете, что в других системах работает так);
- Связывание причины и следствия между собой (определенная кнопка запускает такие-то функции);
- Придумывание негативных проверок или «невозможных» сочетаний причин и следствий (При незаполненных 
  обязательных полях формы, такая-то кнопка неактивна);
- Составление тестовых сценариев — в данном случае очень удобна «таблица принятия решений», о которой 
  будет рассказано в следующем уроке;
- При необходимости (возможности) проводятся уточнения у аналитика тех причин и следствий, которые не 
 описаны в документации.
 
Таким образом, «Причина и следствие» — это особая техника тест-дизайна, которая отображает входные 
данные и ответы системы. Эта техника позволяет существенно сократить число тестов и обратить 
достаточно внимания на более значимые и уязвимые части функционала.

## Таблица принятия решений


Таблица принятия решений состоит из возможных условий (входных данных, ввода), правил (сочетания 
входных данных) и действий, определяемых правилами
Таблицу решений удобно применять в тех случаях, когда поведение системы определяется несколькими 
параметрами, у каждого из которых может быть несколько значений. Как только видите множественные 
формулировки типа: «если A такое, а B вот такое, то C, иначе D», «при A больше стольки и B меньше 
стольки происходит C, в обратном случае D» — это тот случай, когда вам пригодится навык создания 
таблиц решений.

Количество сочетаний (количество правил, количество столбцов/ширина таблицы) определяется 
перемножением количества возможных вариантов каждого параметра.

----------------------------------------------------------------------------------------------------
# HTML

<!--i ["HTML"]-->
**HTML** (`HyperText Markup Language`) — это язык гипертекстовой разметки страницы. Он используется 
для того, чтобы дать браузеру понять, как нужно отображать загруженный сайт. На нем нельзя писать 
программы, но на его основе можно создать веб-страничку.

Основные теги. *Парные теги* состоят из двух частей:*открывающий тег и закрывающий тег*.

`<h1>Это заголовок</h1>`

В закрывающей части перед именем ставится символ / (`«слэш»`). В парные теги можно вкладывать и 
другие теги. Например, как в списoк    `<ul>`

-  `<li>Это элемент ненумерованного списка</li>`

-  `<li>И ещё один</li>`

-  `</ul>`

У вложенных тегов всегда нужно следить за правильным порядком закрытия. Вложенный тег не может 
закрываться позже родительского:

- `<ul><li>Элемент списка</ul></li> <!-- Плохо  -->`

- `<ul><li>Элемент списка</li></ul> <!-- Хорошо -->`

Но, не все теги можно вкладывать в другие теги. Например, тег главного заголовка `<h1>` нельзя 
вкладывать в тег абзаца — `<p>`.

Существуют не только парные, но и *одиночные теги*. Например, тег <img> позволяет добавить картинку 
в разметку. Сам по себе `<img>` не имеет смысла. Чтобы этот тег работал, необходимо написать внутри 
него адрес, ведущий к картинке. Делается это с помощью атрибута `src`:

- `<img src="logo.jpg">`

- `logo.jpg` — это картинка, расположенная  в одной папке с html-документом.

У тега может быть несколько атрибутов, которые нужно писать через пробел:

- `<тег атрибут1="значение1" атрибут2="значение2">`

Картинке, например, можно задать размеры:

- `<img src="logo.jpg" width="200" height="100">`

Код, заключенный между символами `<!-- и -->`, работать не будет. Если эти символы удалить, то код 
заработает. С помощью комментариев обычно временно отключают какой-то код или оставляют подсказки 
для коллег.

- `<!-- Это комментарий в HTML -->`

# CSS

<!--i ["CSS"]-->
**CSS** (`Cascading Style Sheets, каскадные таблицы стилей`) же, в свою очередь, это язык описания 
внешнего вида HTML-документа. Ни один современный сайт не обходится без CSS. Его придумали для 
упрощения кода. До CSS стили задавались в атрибутах HTML-тегов, что затрудняло работу, так как 
увеличивало копипасту кода. Сейчас все CSS-правила задают в отдельном файле, указывая ссылку на него 
в HTML файле. 

````code
p {

    color: red

}
````

## Свойства и правила

С помощью `CSS` можно задавать параметры тега: ширину и высоту, отступы, цвет и размер шрифта, фон 
и так далее. Все эти параметры задаются с помощью свойств в определенном формате:

- свойство: значение;

Например:

`color: red`;

Можно сказать, что CSS-правило — это группа свойств и их значений, относящиеся к тем тегам, на 
которые указывает селектор:

`селектор {свойство1: значение;}`

*Селектор* указывает, к каким тегам применятся CSS-правило. Селекторы по тегам работают проще 
простого: они выбирают все теги с подходящим именем.

`р1 {color: red;}`

## Классы

<!--i ["Классы"]-->
Также, стили к тегам добавляются при помощи атрибута *class*. Классы используются, когда нужно 
указать стили не к конкретным тегам. Например, если необходимо, чтобы определенные стили, описанные, 
допустим, в классе green, применились к тегу <ul>, то в разметке необходимо написать:

`<ul class="green">`

Когда же стили задаются по классам, то стили применяются только к тегам с такими классами.

`.название класса { свойство: значение; }`

Например:

````code
`.green {`

    `color: green;`

`}` 
````

Класс green можно присвоить и к другим тегам.

## Комментарии

<!--i ["Комментарии"]-->
В CSS тоже существуют комментарии, но их отличие от HTML-комментариев в том, что код или подсказки 
пишутся между символами `/* и */`.

`/* Это комментарий в CSS */`

`<h1>Это заголовок</h1>`

## Тестирование дизайна как тестирование верстки

Для создания макетов используются графические редакторы и до недавнего времени довольно 
распространенным решением был **Adobe Photoshop**.
Наиболее распространенным инструментом на данный момент является **Figma**.

## Инструменты тестирования дизайна

<!--i ["Инструменты дизайна"]-->
 Самым мощным инструментом для нахождения несоответствий страницы макету является `PerfectPixel` — 
 устанавливается в качестве расширения для браузера, после чего позволяет на готовую страницу 
 наложить полупрозрачный макет. Все несоответствия сразу будут видны.
 Всю информацию можно взять из кода проекта. К примеру, можно использовать встроенный в браузер 
 инструмент `Devtools`(нажмите F12 или FN и F12, чтобы открыть его), отображающий всю информацию о 
 каждом элементе страницы на вкладках `Elements` и `Styles`.
 
## Элементы интерфейса

<!--i ["интерфейс"]-->
- Кнопка
- Поле ввода
- Радиобаттон (Radiobutton)- с помощью данного элемента можно выбрать одну из предложенных опций.
- Чекбокс (Checkbox) - этот элемент похож на Радиобаттон, но есть несколько отличий - он позволяет 
выбрать несколько опций одновременно,при этом  выбор отмечается “галочкой” в квадрате рядом с 
названием.
- Ссылка
- Выпадающие списки
- Календарь
- Форма - в формах размещают все те элементы, которые были рассмотрены ранее: поля ввода, выпадающие 
списки, чекбоксы, календари, кнопки и т.д. 

## Как работает интернет

<!--i ["интернет", "OSI"]-->
Интернет - система связанных между собой устройств, благодаря которой эти устройства могут 
отправлять друг другу данные.
Модель **OSI - Open Systems Interconnection**. Как раз модель OSI описывает процесс передачи данных. 
Данный процесс разделен на семь уровней.

- На первом уровне `OSI`  данные передаются в виде `физических` сигналов. Сигналы бывают электрические 
или оптические. Железу не дано оценить ваш любимый мем, так как для него - это набор нулей и единиц, 
то есть биты. 
- На следующем уровне - `канальном`, проверяются и исправляются ошибки передачи первого уровня. 
Единицы и нули эволюционируют из `битов в фреймы`. А эти фреймы, как посылки дальним родственникам, 
получают два адреса - адрес отправителя и адрес получателя.
- На `сетевом` уровне наши данные не перестают эволюционировать. На этот раз, `фреймы` становятся 
пакетами. Также наши данные получают IP-адреса по тому же принципу - адрес отправителя и адрес 
получателя.
- Четвертый уровень - `транспортный`, обеспечивает передачу данных по сети. В этом ему помогают два 
протокола - `TCP` и `UDP`. *TCP* протокол гарантированно осуществляет доставку запроса и целостность 
его передачи. Он используется когда пользователь серфит в интернете, пользуется сервисам, соц. сетям 
и прочим. UDP протокол не имеет такой гарантированной передачи данных, как TCP, но у него есть свое 
преимущество - это скорость. *UDP* широко используется для пересылки голосовых и видео в реальном 
времени. А именно, в IP-телефонии и видео звонках/
- `Сеансовый` уровень отвечает за поддержку сеанса или сессии связи. Службы сеансового уровня 
применяются в средах приложений, требующих удаленного вызова процедур, т.е. чтобы запрашивать 
выполнение действий на удаленных компьютерах на одном устройстве. За это отвечает протокол `PAP`. 
Также примером такой работы является онлайн-трансляция на площадке `Twich`. Во время 
онлайн-трансляции необходимо, чтобы два потока данных (аудио и видео) шли синхронно.
- Это уровень `представления` отвечает за кодирование и сжатие данных, для этого используется 
*протокол ASCII*. Именно на этом уровне, твой любимый мем обретает человеческий вид, то есть 
преобразуется в файлы с расширением .jpeg или в подобные. Также шестой уровень отвечает за 
преобразование видео и аудио в понятные форматы для людей. Помимо перечисленного, уровень 
представления переводит текст из одной кодировки в другую, и шифрует данные, чтобы их защитить. 
- `Прикладной` уровень - уровень “для людей”. Его главная задача - отобразить пользователю данные в 
понятном ему виде. Благодаря протоколам прикладного уровня, мы можем серфить по просторам интернета. 
К основным протоколам передачи данных относятся:
 1.`HTTP` - используются для передачи данных в браузере твоих гаджетов;
 1.`SMTP` - используются для передачи электронных писем;
 1.`FTP` - используются для передачи файлов между компьютерами. 
 
Данный подход передачи данных лежит в основе клиент-серверной архитектуры. Данная архитектура 
позволяет разграничить логику работы приложения на два раздела: клиент и сервер. Клиент делает 
запрос к серверу. Сервер отправляет ответ клиенту.

## Как работает веб-приложение

<!--i ["веб-приложение", "фронтенд", "бэкенд"]-->
*Веб-приложение* - это программное обеспечение, которое работает на веб-сервере. В отличие от 
компьютерных программ, которые запускаются локально в операционной системе устройства, 
веб-приложения используют мощности другого оборудования. 

Веб-приложение основано на *клиент-серверной архитектуре*. Значит, принцип работы веб-приложения - 
запрос и ответ.  Как на клиенте, так и на сервере находятся программы. Программы на клиенте называют 
`фронтендом`, а программы на сервере - `бэкендом`. Также на стороне сервера находится база данных.

**Фронтенд** - это все, что видит пользователь, открывая страницу веб-приложения, и с чем он взаимодействует.
В своей работе фронтенд-разработчики используют:

- `HTML` - “скелет” страницы: структура, данные для браузера;
- `CSS` - “стиль” страницы: цвета, шрифты и ее внутреннее наполнение;
- `JavaScript` - логика страницы: слайдеры, калькуляторы, анимации;
- `Фреймворк` - инструмент, упрощающий разработку. Например, `React`.

**Бэкенд** - это фактически то, что скрыто от глаз пользователя и происходит вне его браузера. 
В это же время база данных хранит данные каждого конкретного пользователя. Бэкенд-разработчики 
используют:

- Язык программирования в зависимости от задачи: от C++ до Ruby;
- `SQL` - язык запросов в базы данных, и саму систему управления базами данных;
- Как и фронтенд-разработчики - `фреймворки`.

Например:

- мы совершаем заказ, заполняя все поля и нажимая кнопку “Заказать”;
- фронтенд оформляет нашу пользовательскую информацию;
- браузер отправляет информацию на сервер;
- бэкенд обращается в базу данных, за нужной ему информацией;
- бэкенд обрабатывает полученную информацию заказа; 
- бэкенд оформляет обработанную информацию в ответ;
- сервер отправляет ответ в браузер;
- фронтенд обрабатывает информацию;
- мы получаем информацию вида “Водитель найден. Будет через 5 минут”.

Чтобы сделать запрос к бэкенду, фронтенд обращается к `API` бэкенда. 

**API** - это интерфейс, с помощью которого одна программа общается и обменивается данными с другой.
Данные запроса и ответа API передается в определенном формате, через протокол *HTTP*.  Формата два - 
`JSON` и `XML`.

Существуют разные типы данных, которые принимает поле “значение”.

1. строковый тип данных  *(в JSON к строковому типу данных относятся все данные, закрытые в кавычки);
1. числовой тип данных;
1. булевый тип данных *(true - правда, false - ложь);
1. пустое значение.

И в `XML` и в `JSON` “user” можно считать за объект, к которому относятся вложенные данные.

Также в `JSON` есть особенный тип данных, который можно использовать как список данных - это *массив*. 
Массив определяется квадратными скобками. В массив можно указать несколько значений.

В XML нет массива, поэтому будет дублирование поля “ключ”.
Помимо массива, есть еще и другая структура данных - словарь. **Словарь**, как массив, но немного 
сложнее. Он содержит не только “значение”, но и “ключ”.

## HTTP 

<!--i ["HTTP"]-->
Это протокол прикладного уровня, изначально предназначенный для передачи *HTML-документов*. Кстати, 
HTML - это основа каждого сайта и приложения. Сейчас по HTTP передаются и другие данные: наши 
любимые мемы и забавные видео.

`HTTP` состоит из *стартовой строки*, *заголовков*, *пустой строки* и *тела* сообщения.
В стартовую строку запроса указывают URL-адрес и метод протокола. URL-адрес состоит из различных 
частей: 

- `протокол` - наш друг HTTP или его расширение HTTP(S)**(http//)**.
- `доменное имя` - тот самый, человеческий, адрес (//www.kvch.com.:)
- `порт` - отображает технический параметр, используемый для доступа к ресурсам на сервере. Обычно 
подразумевается, что веб-сервер использует стандартные порты `80` и `443`
- `путь` - это тоже адрес, но в рамках нашего веб-приложения. Например, раздел сайта.
- `параметры` - это дополнительные данные, которые браузер отправляет серверу. Параметры имеют формат 
“ключ=значение” и разделяются между собой знаком `&`. Каждый сервер имеет свои правила обработки этих 
параметров.
- `якорь` - это тоже адрес, но в рамках параметра. Например, ссылка на заголовок.

К основным методам запроса относятся:

- **GET** - получение. Например, при открытии страницы Вконтакте;
- **POST** - создание. Например, при создании нового аккаунта;
- **PUT** - обновление. Например, при редактировании профиля;
- **DELETE** - удаление. Например, при удалении аккаунта.
Есть пять типов статусов ответов:

- **1ХХ** - дают информацию о процессе передачи. Например, мы отправляем связанные между собой запросы. 
Данный код сообщает, что сервер вошел в режим хатико;
- **2ХХ** - дают информацию об успешной передаче. Появляется, когда все работает корректно;
- **3ХХ** - дают информацию о перенаправлении запроса. Также называют `редиректом`. Используются, 
чтобы перенаправить пользователя с одной страницы на другую;
- **4ХХ** - дают информацию об ошибке на стороне клиента. Например, если зайти на несуществующую 
страницу;
- **5ХХ** - дают информацию об ошибке, на стороне сервера. Например, если сервер приложения 
отключили от питания. В заголовок HTTP-протокола указывают служебную информацию запроса. Например, 
информация о нашем браузере и о пользователе.
Между *заголовками* и *телом* ставятся пустая строка, чтобы браузер смог отличать блоки. А в тело 
запроса указываем данные переданные серверу, а в тело ответа данные, которые отправляет нам сервер.

Важно помнить, что HTTP передает данные в открытом виде. Поэтому придумали расширение HTTP(S), 
позволяющий шифровать отправленные и полученные данные.

# Чек-лист проверки веб-приложения

Функциональная проверка:                                                                    Результат:

- Проверить, что для всех браузеров требуются одни и те же шрифты 
- Проверить правильность используемых ссылок на файлы и сайты
- Проверить, что графические изображения имеют подходящие размеры и разрешение
- Проверить орфографию 
- Проверить валидацию всех веб-форм 
- Проверить, что пропускная способность и время отклика соответствует документированным 
 характеристикам производительности  
- Проверить, что все транзакции выполняются надлежащим образом 
- Проверить корректную работу средств отката транзакций  
- Проверить корректность процесса сбора данных
- Проверить, что производительность операций с базой данных соответствует ожидаемой
- Проверить корректность и достоверность сохраняемых данных
- Проверить возможность восстановления данных
- Проверить корректность обработки отказов и ситуаций с избыточным количеством обрабатываемых данных
- Проверить средства шифрования и защиты данных 
- Проверить правильность работы подпрограмм обработки данных сервера СУБД (системы управления базами 
данных)

 

