<!--VARIABLES {"title": "Методы тестирования", "SORT_ORDER": "30"}-->

[TOC]

----------------------------------------------------------------------------------------------------
<!--i ["баг"]-->
# Баг

Что же такое - баг? Ron Patton дает следующее определение загадочному слову *software bug*:

1. Продукт не делает что-то, что, согласно спецификации (далее - ТЗ), должен делать.
2. Продукт делает что-то, что, согласно ТЗ, делать не должен.
3. Продукт делает что-то, что в ТЗ не указано.
4. Продукт не делает что-то, что в ТЗ не указано, хотя должно.
5. Продукт очень сложный для понимания, трудный в использовании, медленный, или - глазами тестировщика, 
  который смотрит на продукт как конечный пользователь,  делает что-то... просто не правильно!
  
Начинающие тестировщики часто сосредоточиваются на первых трех пунктах.
Не зная, куда податься, они пытаются по крайней мере убедиться в том, что конечный продукт 
соответствует спецификации.

Очень важным является именно 4 пункт. Фактически этот пункт означает ошибку в ТЗ. А, как все мы 
знаем, ТЗ тоже надо тестировать. На полноту, корректность, осуществимость, необходимость, 
повторяемость и недвусмысленность.

----------------------------------------------------------------------------------------------------
<!--i ["ISTQB"]--> 
# ISTQB 

**ISTQB** --- Совет по сертификации тестирования программного обеспечения, действующий на 
международном уровне.


<!--i ["black box", "метод черного ящика"]--> 
## Метод черного ящика (black box)

Согласно ISTQB, тестирование черного ящика — это:

- тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего 
    устройства компонента или системы;
- тест-дизайн, основанный на технике черного ящика — процедура написания или выбора тест-кейсов на 
    основе анализа функциональной или нефункциональной спецификации компонента, или системы без знания 
    ее внутреннего устройства.

*Преимущества:*

- тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и 
    противоречия в спецификации;
- тестировщику нет необходимости обладать дополнительными знаниями в программировании; 
- можно начинать писать тест-кейсы, как только готова спецификация.

*Недостатки:*

- тестируется только очень ограниченное количество путей выполнения программы;
    без четкой спецификации (а это, скорее, реальность на многих проектах) достаточно трудно составить 
    эффективные тест-кейсы;
- некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне 
    модульного тестирования.
    
!!! note "Пример"
    Обычный калькулятор. У нас нет доступа к внутренней системе, но мы можем предположить как 
    пользователь будет им пользоваться и на основе этого произвести тестирование функций: отображение 
    цифр при нажатии на кнопки, работу операторов(сложение, вычитание и т.д.), удаление результата и т.д.
 
<!--i ["white box", "метод белого ящика"]--> 
## Метод белого ящика (white box)

Тестирование белого ящика ( полный доступ к коду / сам писал код ) — метод тестирования ПО, который 
предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику.
Как правило, таким видом тестирования на проектах занимаются сами программисты, ведь для 
использования этого метода тестировщик должен обладать достаточно высокой квалификацией. 

Согласно ISTQB, тестирование белого ящика — это:

- тестирование, основанное на анализе внутренней структуры компонента или системы;
- тест-дизайн, основанный на технике белого ящика — процедура написания или выбора тест-кейсов на 
  основе анализа внутреннего устройства системы или компонента.
  
*Преимущества:*

- тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского 
    интерфейса;
- можно провести более тщательное тестирование с покрытием большого количества путей выполнения 
    программы.

*Недостатки:*

- для выполнения тестирования белого ящика необходимо большое количество специальных знаний;
- упор делается на код, без учета позиции конечного пользователя, вследствие чего могут пропускаться 
    баги.
    
Пример: двигатель автомобиля. Для водителя (особенно начинающего) двигатель автомобиля - черный ящик. 
Но, для механика нет. Он, словно программист, понимает логику работы компонентов двигателя и знает 
его слабые места.


<!--i ["grey box", "метод серого ящика"]--> 
## Метод серого ящика (grey box)

Тестирование серого ящика ( частичный доступ к коду ) — метод тестирования ПО, который предполагает 
комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно 
лишь частично.

*Преимущества:*

- Тестирование серого ящика включает в себя плюсы тестирования «черного» и «белого». Другими словами, 
тестировщик смотрит на объект тестирования с позиции «черного» ящика, но при этом проводит анализ на 
основе тех данных, что он знает о системе;
- Тестировщик может проектировать и использовать более сложные сценарии тестирования;
Предоставляет разработчику достаточно времени для исправления дефектов.

*Недостатки:*

- Возможность анализа кода и тестового покрытия ограничена, так как доступ к исходному коду ограничен.
- Тесты могут быть избыточными в том случае, когда разработчик также проверяет свой код Unit-тестами.

Пример: разработчик, проверяющий программу, методом черного ящика ИЛИ тестировщик, ознакомившийся с 
архитектурой программы, проверяющий программу, методом черного ящика. Оба понимают логику работы 
программы, но проверяют ее, с точки зрения пользователя. 

----------------------------------------------------------------------------------------------------
<!--i ["уровни тестирования"]--> 
# Уровни тестирования

Выделяют четыре уровня тестирования:

- Модульное тестирование (Component/Unit testing);
- Интеграционное тестирование (Integration testing);
- Системное тестирование (System testing);
- Приемочное тестирование (Acceptance testing).

Задачи любого уровня тестирования:

- Снижение риска;
- Обнаружение дефектов;
- Предотвращение перехода дефектов на более высокие уровни.


<!--i ["модульное тестирование"]--> 
## Модульное тестирование

Для обозначения модульного тестирования используется множество синонимичных названий: `модульное`, 
`юнит` или `компонентное`.

*Модульное* тестирование проводится, вызывая код,  и позволяет проверить, что отдельные части общего 
кода работают согласно требованиям документации.
Модульное тестирование, как правило, проводится разработчиками.


<!--i ["интеграционное тестирование"]--> 
## Интеграционное тестирование --- это тестирование взаимодействия модулей системы или нескольких систем.

Так как разные модули приложения могут разрабатываться разными программистами - необходимо проверить 
взаимодействие между ними.

Один компонент (модуль) производит выходные данные, а другой компонент эти данные принимает на вход. 
Проверка правильности взаимодействия этих отдельных модулей или систем и называется `интеграционным` 
тестированием.

В результате тестирования стоит ожидать, что все смежные системы и модули одной системы должны 
работать согласованно.

*Типичные тестовые объекты:*

- Подсистемы;
- Базы данных;
- Интерфейсы, с помощью которых взаимодействует система;
- Микросервисы.

*Типичные дефекты:*

- Отсутствующие или неправильные данные;
- Сбои связи между компонентами;
- Нарушение обязательных правил безопасности.


  
## Системное тестирование (System testing) производится после окончания интеграционного. 
Сначала разработчики создают и тестируют модули, затем 
интегрируют и тестируют модули между собой. В результате получается некая завершенная система, 
базовая модель приложения.

*Цель* системного тестирования: проверить все приложение целиком.
На системном уровне тестирования проводится тестирование полного пути (end-to-end/E2E flow)
использования продукта. Под путем использования понимается вся цепочка взаимодействия от запуска 
приложения до какого-то конечного результата.

Пример сценария **end-to-end** для интернет магазина:

- Незарегистрированный пользователь переходит на сайт интернет магазина;
- Регистрируется на сайте;
- Авторизуется на сайте;
- Находит необходимый товар;
- Добавляет его в корзину;
- Статус заказа «Ожидает оплаты»;
- Оплачивает заказ;
- Деньги поступают на счет компании;
- Статус заказа меняется на «Оплачен»;
- После получения заказа пользователем статус заказа меняется на «Получен».

*Типичные дефекты:*

- Неожиданное или неверное поведение системы;
- Система неспособна выполнять end-to-end задачи;
- Система неспособна правильно работать в различных средах;
- Система работает не в соответствии с пользовательским руководством.


<!--i ["приемочное тестирование"]--> 
## Приемочное тестирование (Acceptance testing)

На текущем уровне тестирования обязательно должны применяться реальные данные и реальное 
использование приложения. Такой подход делает приемочное тестирование очень важным этапом цикла 
выпуска приложения. Это окончательное тестирование, выполняемое после завершения модульного, 
интеграционного и системного тестирования

*Критерии приемки* — это условия, которым должно удовлетворять приложение, чтобы быть принятыми 
заказчиком.

Приемочное тестирование включает следующие формы:

- Пользовательское приемочное тестирование (`User acceptance testing`)  —  производится пользователями 
    конечного продукта;
- Операционные приемочные испытания (`Operational acceptance testing`) - как правило, проводят 
    системные администраторы. Проверяется функции резервного копирования, установка/ удаление/ 
    обновление системы, проверка безопасности и производительности приложения. Необходимо удостовериться, 
    что приложение возможно обслуживать и сопровождать на требуемом уровне даже в экстремальных условиях;
- Контрактные и нормативные приемочные испытания (`Contractual and regulatory acceptance testing `)  —  
    проверка, что приложение соблюдает все нормативные требования, продукт не нарушает чью-то 
    интеллектуальную собственность или не использует нелицензионный софт;
- Альфа и бета-тестирование (`Alpha and beta testing` ).


<!--i ["альфа и бета- тестирование"]--> 
## Альфа и бета-тестирование

Альфа тестирование  включает имитацию реального использования продукта штатными  или сторонними 
разработчиками, либо командой тестировщиков.

Бета-тестирование  —  производится реальными пользователями, с целью получения от них обратной связи 
и выявления максимального числа ошибок для их последующего устранения перед окончательным выходом 
продукта на рынок (релизом).

----------------------------------------------------------------------------------------------------
# Формальность 
 
Рассмотрим подходы к тестированию по степени формализации: 

<!--i ["тестирование на основе **тест-кейсов"]-->
1.Тестирование на основе **тест-кейсов**.
    Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых 
    для проверки реализации функционала тестируемого программного обеспечения (ПО) или какого-то его 
    свойства.
    
    Эта информация включает в себя четкое описание действий, которые нужно выполнить, шаг за шагом. 
    После выполнения действий нужно сравнить ожидаемый результат работы приложения с тем, который 
    получен.
    
    Это самый распространенный способ тестирования, который также позволяет достичь максимальной 
    полноты исследования продукта за счет строгой систематизации процесса. 

<!--i ["исследовательское тестирование", "Exploratory testing"]-->
2.**Исследовательское тестирование** (`Exploratory testing`)    
    Exploratory testing — это частично формализованный подход тестирования ПО, при котором тестовые 
    наборы не создаются заранее, а тестировщик проверяет приложение «на лету».
    Тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, 
    дорабатывается в процессе выполнения с целью более полного исследования приложения.
    Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, 
    а не как на бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию 
    ты сначала разрабатываешь тестовые случаи, а затем исполняешь их. Исследовательское тестирование — 
    это одновременный процесс разработки и выполнения тестов.
    В качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться 
    чек-листы.
    Также в результате исследовательского тестирования могут появиться новые тест- кейсы. То есть мы 
    можем выполнять исследовательское тестирование и с целью написания новых тест-кейсов.

<!--i ["интуитивное тестирование", "Monkey Testing"]-->
3.**Свободное** (`интуитивное`) тестирование (`Ad Hoc Testing` или `Monkey Testing`)
    полностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни 
    чек-листов, ни сценариев.

Тестировщик полностью опирается на свою интуицию для спонтанного выполнения с продуктом действий, 
которые, как он считает, могут обнаружить ошибку.

Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует 
придерживаться при выполнении тестирования. Таким образом, метод не структурирован, и, следовательно, 
дефекты, обнаруженные с помощью этого метода, может быть труднее воспроизвести, но и вместе с этим 
возможно найти «Хитрые баги».

В свою очередь *Интуитивное тестирование* подразделяется на 2 вида:

`buddy testing` (*совместное тестирование*) — когда 2 человека, как правило разработчик + тестировщик, 
работают параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает 
тестировщику выполнять необходимые проверки, а программисту фиксить баги на ранних этапах.

`pair testing` (*парное тестирование*) —  когда 2 тестировщика проверяют один модуль и помогают друг 
другу. К примеру, один может искать дефекты, а второй —  их документировать.


<!--i ["статическое тестирование", "static testing", "code review"]-->
## Статическое тестирование (`Static Testing) 

Статическое тестирование --- тип тестирования, при котором код программы не 
исполняется во время проведения тестов. Оно включает тестирование спецификации и прочей документации, 
файлов, либо 
тестирование и анализ программного кода (`code review`) или скомпилированного кода без его запуска. 
Может производиться как вручную, так и с помощью специальных инструментальных средств, т.е .
автоматизировано.

Код-ревью (`code review`) может выполняться одним из участников команды разработчиков или 
тестировщиком. Как правило, на код-ревью проверяются качество кода, стандарты использования, решения 
реализации, оставляются комментарии. Это помогает предотвратить дефект на начальном этапе.


<!--i ["динамическое тестирование", "dynamic testing"]-->
## Динамическое  тестирование

Динамическое  тестирование (`Dynamic Testing`) — тестирование, при котором выполняется код 
программы и проверяется поведение приложения во время работы. Тут происходит взаимодействие с 
интерфейсом запущенной программы, ее формами, сервером, базой данных и т.д.

Если проводятся тесты на работающем приложении — значит, это *динамические* тесты.

При **Ручном тестировании** (`Manual Testing`) тестировщик выполняет тесты, не используя каких-либо 
средств автоматизации;

**Автоматизированное тестирование** (`Automation Testing`) предполагает использование специального 
программного обеспечения (помимо тестируемого) для контроля выполнения тестов и сравнения ожидаемого 
фактического результата работы программы.

----------------------------------------------------------------------------------------------------
<!--i ["функциональное тестирование", "functional testing"]-->
# Функциональное тестирование (`Functional Testing`)

Оно включает в себя тесты, оценивающие функции приложения. Функции системы — это то, «что» должна 
делать система.

С помощью этого вида приложение проверяется на способность выполнять свои функции. Сюда входят: 
модульное, интеграционное, системное и приемочное тестирование. Кроме того, регрессионное и дымовое 
тестирования тоже являются подвидами функционального. Исполняется функциональное тестирование на 
основании требований в виде спецификаций или пользовательских историй.

По хронологии тестирование разделяют на:

- *Дымовое тестирование* (`Smoke Testing`) - включает в себя минимальный набор тестов на самые 
очевидные ошибки. Дымовое тестирование проверяет работоспособность критически важных функциональных 
частей приложения.

Например, регистрация нового пользователя, создание нового заказа, выставление счета клиенту, 
получение оплаты. Это базовый функционал, который регулярно контролируется Smoke-тестами.

- *Санитарное тестирование* (`Sanity Testing`) — проводится после незначительных изменений в 
функционале, коде или починке багов. Проверяет, что исправленный код или новый функционал работает, 
как и ожидалось.

Как пример, программисты устранили дефект на странице создания нового заказа. В этом случае 
санитарные тесты должны проверить общее состояние приложения и нацелены на то, чтобы избежать потерь 
времени и усилий, чтобы быстрее определить возможные недостатки ПО и их критичность, а также стоит 
ли переходить в фазу более тщательного тестирования. Обычно выполняется вручную.

- *Регрессионное тестирование* (`Regression Testing`) — тестирование приложения, направленное на 
обнаружение ошибок в уже проверенных участках программ (или исходных кодах). Помогает убедиться, что 
недавние изменения не сломали работающую функциональность приложения. Регрессионные тесты должны 
проводиться при любых изменениях кода, потому полная автоматизация — лучшая практика в этом типе 
тестирования.

В регрессию включаются тесты, которые покрывают тестирование безопасности, критических и важных 
функций. Включаются те области, которые часто меняются в ходе разработки, где высока вероятность 
ошибки.

- *Повторное тестирование* (`Retesting`) — проводится после устранения дефекта в части функционала с 
целью подтверждения исправления ошибки.  Перепроверяет и подтверждает то, что ранее неудачные 
тест-кейсы успешно проходятся после того, как эти дефекты были исправлены. При этом используются те 
же самые тест-кейсы, которые выявили дефект — с использованием тех же данных, на том же окружении, 
но с различным набором входных данных.

----------------------------------------------------------------------------------------------------
<!--i ["нефункциональное тестирование", "non-functional testing"]-->
# Нефункциональное тестирование (`Non-functional Testing`)

*Нефункциональное тестирование* оценивает характеристики систем и программного обеспечения, такие 
как надежность, производительность, удобство использования, эффективность работы или его 
безопасность. Нефункциональное тестирование — это проверка того, «насколько хорошо» ведет себя 
система.

- Тестирование *графического интерфейса* (`User interface testing`) — проверка соответствия 
интерфейса ПО требованиям дизайна.

- *Пользовательский интерфейс* (`user interface (UI)`) — это интерфейс, который позволяет 
пользователям взаимодействовать  с ПО, используя при этом визуальные индикаторы и графические значки.

- *UI-тесты* включают в себя проверку наличия всех требуемых элементов на странице, их размеров и 
расположения, тестирование шрифтов, цветов, изображений .

- *Тестирование удобства пользования* (`Usability Testing`) — определение удобства использования 
приложения. Проверяется эргономичность интерфейсов. Например, оформление и графические элементы с 
точки зрения удобства восприятия, удобство навигации. В этот вид входит Тестирование доступности.

- *Тестирование доступности* (`Accessibility Testing`) — проверка доступности приложения для людей 
с ограниченными возможностями (пользователям с нарушением слуха, зрения (цветовосприятия), а также 
людях, у которых нет возможности использовать клавиатуру). 

Например использование определенной цветовой гаммы, добавление субтитров на видео или озвучивание 
всей страницы.

- *Тестирование производительности* (`Performance Testing`) — тестирование скорости работы 
приложения под определённой нагрузкой.

- *Нагрузочное тестирование* (`Load testing`) — данный тип тестирования позволяет оценить поведение 
системы при нормальных условиях и возрастающей нагрузке, целью нагрузочного тестирования является 
также определение максимальной нагрузки, которую может выдержать система.

Например, мы рассчитываем, что одновременно приложением будет пользоваться 500 пользователей, и 
через специальные программы (например `Jmeter`) создаются условия, которые моделируют использование 
приложения одновременно чуть менее 500 пользователями.

- *Стресс-тестирование* (`Stress testing`) — используется для определения устойчивости системы или 
модуля при пороговых значениях рабочей нагрузки или за ее пределом. К примеру моделируются условия 
одновременного использования 500 или немногим более пользователей.

- *Объемное тестирование* (`Volume testing`) — тестирование позволяет оценить производительность 
системы при увеличении объемов данных как самого приложения, так и его базы данных. Когда те же 500 
пользователей отправляют одновременно какой-то объем информации.

- *Тестирование надежности* (`Reliability Testing`) — проверка работоспособности приложения при 
длительном тестировании с ожидаемым уровнем нагрузки.

- *Тестирование безопасности* (`Security Testing`) — оценка уязвимости приложения к различным атакам. 
Оценка безопасности пользовательских данных, на сколько просто неавторизованный пользователь может 
получить доступ к системе или данных.

- *Тестирование Установки* (`Installation Testing`) — проверка успешной инсталляции, настройки, 
обновления и удаления.

- *Тестирование совместимости* (`Compatibility Testing`) — проверка корректной работы приложения в 
определенном окружении, например, устройстве, операционной системе (кроссплатформенное тестирование) 
или браузере (кроссбраузерное тестирование).

- *Тестирование на отказ и восстановление* (`Recovery Testing`) — проверка насколько хорошо 
приложение может оправиться от аварий и сбоев оборудования.

- *Тестирование локализации* (`Localization Testing`) — тестирования локализованной версии 
приложения: проверка правильности перевода интерфейса пользователя, системных сообщений и ошибок, 
раздела "Помощь"/"Справка",  документации, контроль формата даты и времени.

- *Тестирование интернационализации* (`Internationalization Testing`) — Насколько продукт может 
адаптироваться для той или иной локали при выходе на другие рынки. Например, возможность поддержки 
вертикального текста Азиатских стран, чтение справа налево в арабских странах.

----------------------------------------------------------------------------------------------------
# Testing

## Unit testing

Перед началом тестирования нужно убедиться, что:

1. Код заморожен (обычно релиз-инженеры посылают соответствующий е-мейл);
1. Версия продукта на внутреннем сайте, на котором вы будете
    производить тестирование, является именно той версией,
    которую вам нужно протестировать.
    
----------------------------------------------------------------------------------------------------
<!--i ["чек-лист", "checklist", "контрольный список"]--> 
# Чек-лист

**Чек-лист** (по-русски часто называется *контрольным списком*) для тестирования веб-приложений 
состоит из:

- Тестирования удобства использования.
- Функционального тестирования.
- Тестирования совместимости.
- Тестирования баз данных.
- Тестирования безопасности.
- Тестирования производительности.
- Теперь давайте рассмотрим каждый пункт по отдельности.

**Тестирование удобства использования** --- это тестирование дружелюбности приложения для пользователя.
При тестировании удобства использования проверяется, легко ли новому пользователю разобраться в 
приложении. В целом при тестировании удобства использования тестируется системная навигация.
   
Тест удобства использования удостоверяется в простоте и эффективности использования продукта при 
использовании стандартных практик тестирования удобства использования.

### Сценарии тестирования удобства использования:

- Содержание веб-страницы верное, без грамматических и орфографических ошибок.
- Все шрифты соответствуют требованиям.
- Все тексты правильно выровнены.
- Все сообщения об ошибках верные, без орфографических и грамматических ошибок, и соответствуют 
  заголовку окна.
- Подсказки существуют для всех полей.
- Все поля правильно выровнены.
- Между полями, колонками, рядами и сообщениями об ошибках оставлено достаточно свободного места.
- Все кнопки должны иметь стандартный формат и размер.
- Ссылка на домашнюю страницу должна быть на каждой странице сайта.
- Неактивные поля должны быть серыми.
- Проверьте, что на сайте нет битых ссылок и изображений.
- Подтверждающие сообщения должны отображаться для всех операций обновления и удаления.
- Проверьте сайт при разных разрешениях экрана ((640 x 480, 600x800 и т. д.)
- Проверьте, что пользователь может пользоваться системой без раздражения.
- Проверьте, что TAB правильно работает.
- Панель скролла должна появляться только тогда, когда она требуется.
- Если при отправке формы есть сообщения об ошибке, в нем должна содержаться информация, переданная 
  пользователем.
- Заголовок должен отображаться на каждой странице.
- Все поля (текстовые, выпадающие меню, радио-кнопки и т. д.) и кнопки должны быть доступны с 
  клавиатуры, и пользователь должен быть в состоянии пользоваться сайтом, используя только клавиатуру.
- Убедитесь, что данные в выпадающих списках не обрезаются из-за размеров поля, и проверьте, зашиты 
  ли данные в код или управляются администратором.
  
## Функциональное тестирование

Тестирование функциональностей и операционного поведения продукта с целью убедиться, что они 
соответствуют спецификациям. Тестирование, игнорирующее внутренние механизмы системы или компонента. 
Оно концентрируется исключительно на выходных данных, полученных в ответ на пользовательский ввод и 
условия исполнения сценариев.

Цель функционального тестирования – убедиться, что ваш продукт соответствует нужной функциональной 
спецификации, упомянутой в вашей документации по разработке.

### Сценарии функционального тестирования:

- Протестируйте валидацию всех обязательных полей
- Убедитесь, что знак звездочки отображается у всех обязательных полей
- Убедитесь, что система не отображает окно ошибки при незаполненных необязательных полях.
- Убедитесь, что високосные коды корректно валидируются и не вызывают ошибок в расчетах.
- Протестируйте числовые поля: они не должны принимать буквы, в этом случае должно отображаться 
  соответствующее сообщение об ошибке.
- Протестируйте отрицательные значения в числовых полях, если они разрешены.
- Протестируйте, что деление на ноль верно обсчитывается.
- Протестируйте максимальную длину каждого поля, чтобы убедиться, что данные не обрезаются.
- Протестируйте всплывающее сообщение ("Это поле ограничено 500 знаками"), которое должно 
  отобразиться, если введенные данные превышают разрешенный размер поля.
- Убедитесь, что подтверждающее сообщение отображается для операций обновления и удаления.
- Убедитесь, что значения стоимости отображаются в нужной валюте.
- Протестируйте все поля ввода на спецсимволы.
- Протестируйте функциональность тайм-аута.
- Протестируйте функциональность сортировки.
- Протестируйте функциональность доступных кнопок.
- Протестируйте условия использования и часто задаваемые вопросы: они должны быть внятными и 
  доступными пользователю.
- Протестируйте, что при отказе функциональности пользователь перенаправляется на специальную 
  страницу ошибки.
- Протестируйте, что все загруженные документы правильно открываются.
- Протестируйте, что пользователь может скачать загруженные файлы.
- Протестируйте почтовую функциональность системы.
- Протестируйте, что Java Script верно работает в разных браузерах (IE, Firefox, Chrome, Safari, Opera).
- Посмотрите, что будет, если пользователь удалит куки, находясь на сайте.
- Посмотрите, что будет, если пользователь удалит куки после посещения сайта.
- Протестируйте все данные в выпадающих списках: они должны быть расположены в хронологическом порядке.


## Тестирование совместимости

Тестирование совместимости используется, чтобы убедиться, что ваше приложение совместимо с другими 
элементами системы, в которой оно работает – например, браузерами, операционными системами или железом.

Цель тестирования совместимости – оценка того, насколько хорошо ПО работает в определенном браузере, 
под определенной ОС, с другим ПО или железом.


### Сценарии тестирования совместимости:

- Протестируйте сайт в различных браузерах (IE, Firefox, Chrome, Safari, Opera) и убедитесь, что 
  сайт правильно отображается.
- Убедитесь, что используемая версия HTML совместима с соответствующими версиями браузеров.
- Убедитесь, что картинки корректно отображаются в разных браузерах.
- Убедитесь, что шрифты верно отображаются в разных браузерах.
- Убедитесь, что Java Script код работает в разных браузерах.
- Проверьте анимированные GIF в разных браузерах.


## Инструмент для тестирования совместимости

**Spoon.net**: Spoon.net предоставляет доступ к тысячам приложений (браузеров), не требующих 
установки. Этот инструмент помогает вам тестировать приложение в разных браузерах на одной и той же машине.


## Тестирование баз данных

При тестировании баз данных проверяются бэкэнд-записи, введенные через веб или десктоп-приложение. 
Данные, которые отображаются в приложении, должны совпадать с данными, хранящимися в базе данных.
Чтобы тестировать базы данных, тестировщик должен знать следующее:

- Тестировщик должен понимать функциональные требования, бизнес-логику, основной сценарий приложения 
  и дизайн базы данных.
- Тестировщик должен разбираться в таблицах, триггерах, процедурах хранения, способах отображения и 
  указателях, используемых для приложения.
- Тестировщик должен понимать логику триггеров, процедур хранения, способов отображения и указателей.
- Тестировщик должен понимать, какие таблицы затрагиваются, когда операции вставки, обновления и 
  удаления выполняются в приложении.
- Понимая вышеперечисленные пункты, тестировщик может легко написать сценарии для тестирования баз данных.


### Сценарии тестирования баз данных:

- Проверьте название базы данных: оно должно совпадать со спецификацией.
- Проверьте таблицы, колонки, типы колонок и значения по умолчанию: все это должно совпадать со 
  спецификацией.
- Проверьте, позволяет ли колонка значение null.
- Проверьте первичный и внешний ключ каждой таблицы.
- Проверьте процедуры хранения.
- Протестируйте, установлена ли процедура хранения.
- Проверьте название процедуры хранения.
- Проверьте названия параметров, их типы и количество.
- Проверьте, обязательны параметры или нет.
- Проверьте процедуру хранения, удалив некоторые параметры.
- Проверьте базу данных, если на выходе ноль – записи с нулем должны быть задействованы.
- Проверьте процедуру хранения, задав простые SQL-запросы.
- Убедитесь, что процедура возвращает значения.
- Проверьте процедуру вводом тестовых данных.
- Проверьте поведение каждого флага в таблице.
- Убедитесь, что данные правильно сохраняются в базе данных после каждого ввода.
- Проверьте данные при каждой операции обновления, удаления и вставки.
- Проверьте длину каждого поля. Длина на бэкэнде и фронтэнде должны совпадать.
- Проверьте названия баз данных QA, UAT и прода. Имена должны быть уникальными.
- Проверьте зашифрованные данные в базе.
- Проверьте размер базы и время отклика на каждый запрос.
- Проверьте данные, отображающиеся на фронтэнде, и убедитесь, что они совпадают с бэкэндом.
- Проверьте целостность данных, вводя невалидные значения в базу.
- Проверьте триггеры.


##  Тестирование безопасности

Тестирование безопасности нацелено на поиск недостатков и пробелов с точки зрения безопасности 
приложения.

### Сценарии тестирования безопасности:

- Убедитесь, что страницы, содержащие важные данные (пароль, номер кредитной карты, ответы на 
  секретные вопросы и т. п.) открываются через HTTPS (SSL).
- Убедитесь, что важная информация (пароль, номер кредитной карты) отображается в зашифрованном виде.
- Убедитесь, что правила создания паролей внедрены на всех страницах авторизации (регистрация, 
  страница "забыли пароль", смена пароля).
- Убедитесь, что если пароль изменен, пользователь не может зайти под старым.
- Убедитесь, что сообщения об ошибках не содержат никакой секретной информации.
- Убедитесь, что если пользователь вышел из системы или сессия завершена, он не может пользоваться 
  сайтом.
- Проверьте доступ к закрытым и открытым страницам сайта напрямую без авторизации.
- Убедитесь, что опция "Просмотр исходного кода" отключена и не видна пользователю.
- Убедитесь, что учетная запись пользователя блокируется, если он несколько раз ввел пароль неверно.
- Убедитесь, что пароль не хранится в куки.
- Убедитесь, что если какая-либо функциональность не работает, система не отображает информацию о 
  приложении, сервере или базе данных. Вместо этого отображается соответствующее сообщение об ошибке.
- Проверьте сайт на SQL-инъекции.
- Проверьте права пользователей и их роли. К примеру, кандидат не должен быть способен получить 
  доступ к странице администратора.
- Убедитесь, что важные операции пишутся в логи, и информацию можно отследить.
- Убедитесь, что значения сессий отображаются в адресной строке в зашифрованном виде.
- Убедитесь, что куки хранятся в зашифрованном виде.
- Проверьте приложение на устойчивость к брутфорс-атакам.


## Тестирование производительности

Тестирование производительности проводится для оценки соответствия системы или компонента 
специфичным требованиям к производительности.

### Общие тестовые сценарии:

- Определение производительности, стабильности и масштабируемости приложения под разной нагрузкой.
- Определение, может ли актуальная архитектура поддерживать приложение при пиковых нагрузках.
- Определение, какая конфигурация приводит к наилучшим показателям производительности.
- Определение бутылочного горла приложения и инфраструктуры.
- Определение, не изменилось ли время отклика у новой версии приложения.
- Оценка продукта и/или железа с целью удостовериться, что они выдержат прогнозируемые объемы нагрузки.

Как проводится тестирование производительности? Вручную или автоматически?

В целом невозможно проводить тестирование производительности вручную по ряду причин:

- Понадобится большое количество ресурсов.
- Невозможно одновременно осуществлять ряд действий.
- Отсутствует подходящий способ отслеживания поведения системы.
- Сложность выполнения повторяющихся задач.
- Чтобы справиться с вышеперечисленными проблемами, используются специальные инструменты 
  тестирования производительности. 
  
Ниже перечислены некоторые из них:.

- Apache JMeter
- Load Runner
- Borland Silk Performer.
- Rational Performance Tester
- WAPT
- NEO LOAD