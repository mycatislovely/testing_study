<!DOCTYPE html>
<html>
<head><title>Методы тестирования</title>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/png" href="../pict/favicon.png"/>
<link rel="stylesheet" type="text/css" href="../layout/styles.css"/>
<link rel="stylesheet" type="text/css" href="../layout/layout.css"/>
<link rel="stylesheet" type="text/css" href="../theme.css"/>

<style>
.headerNavArrows {position: relative; top: 3px;}
</style>
</head>
<body>

<div class="header"><b><span style="color:#59f;margin-right:7px;">Test</span></b><a 
class="header_item" href="index_page.html">Index</a>

<a href="../../doc_src/testing_methods.txt " class="header_item_source" title="Source text">&lt;/&gt;</a>


<a href="testing.html" title="Previous: Тестирование"><img class="headerNavArrows" src="../layout/pict/previous_page_h18px.png"/></a>

<a href="artifacts.html" title="Next: Артифакты"><img class="headerNavArrows" src="../layout/pict/next_page_h18px.png"/></a>


<span class="headerTitle">Методы тестирования</span>

</div>

<div class="sidebar">
    <table class="sidebarAligner">
        <tr><td valign="top">
            <div class="sidebar_item"><a href="для видео.html"></a></div>
<div class="sidebar_item"><a href="about.html">Введение</a></div>
<div class="sidebar_item"><a href="terms.html">Терминология</a></div>
<div class="sidebar_item"><a href="testing.html">Тестирование</a></div>
<div class="sidebar_item selected"><a href="testing_methods.html">Методы тестирования</a></div>
<div class="sidebar_item"><a href="artifacts.html">Артифакты</a></div>
<div class="sidebar_item"><a href="test_design.html">Тест дизайн</a></div>
<div class="sidebar_item"><a href="Postman_testing.html">Postman</a></div>
<div class="sidebar_item"><a href="databases.html">Базы данных</a></div>
            <h3>Course</h3>
            <div class="sidebar_item"><a href="course/about_the_course.html">О курсе</a></div>
<div class="sidebar_item"><a href="course/life_cycle.html">Жизненный цикл ПО</a></div>
            <h3>Technologies</h3>
            <div class="sidebar_item"><a href="technologies/web_technologies.html">Сетевые технологии</a></div>
            <h3>Useful links</h3>
            <div class="sidebar_item"><a href="https://vladislaveremeev.gitbook.io/qa_bible/">QA Библия</a></div>
<div class="sidebar_item"><a href="https://github.com/Kakha-Khinikadze/Links-QA/blob/master/Links.md">Энциклопедия джуна</a></div>
<div class="sidebar_item"><a href="https://xn--90aexm.xn--b1agwec.xn--p1ai/2020/01/testovye-ploschadki-dlya-trenirovok/">Подборка площадок</a></div>
<div class="sidebar_item"><a href="https://artsiomrusau.com/articles/">Огромный список ресурсов</a></div>
<div class="sidebar_item"><a href="https://tproger.ru/articles/shpargalki-po-sql/">Шпаргалки по SQL</a></div>
<div class="sidebar_item"><a href="https://telegra.ph/Samaya-interesnaya-chast-sobesedovaniya-testirovshchika-zadachi-na-logiku-07-13">задачки на логику</a></div>
        </td></tr>
        <tr><td class="bottom" valign="bottom">
            Generated by md2html_py 1.0.2
            <br />2023-04-30 13:07:58
        </td></tr>
    </table>
</div>

<p style="font-size:44px;font-weight:bold;margin:0 0 30px 0;">Методы тестирования</p>

<div class="toc">
<ul>
<li><a href="#_1">Баг</a></li>
<li><a href="#istqb">ISTQB</a><ul>
<li><a href="#black-box">Метод черного ящика (black box)</a></li>
<li><a href="#white-box">Метод белого ящика (white box)</a></li>
<li><a href="#grey-box">Метод серого ящика (grey box)</a></li>
</ul>
</li>
<li><a href="#_2">Уровни тестирования</a></li>
<li><a href="#_3">Модульное тестирование</a></li>
<li><a href="#_4">Интеграционное тестирование</a><ul>
<li><a href="#system-testing">Системное тестирование (System testing)</a></li>
<li><a href="#acceptance-testing">Приемочное тестирование (Acceptance testing)</a></li>
</ul>
</li>
<li><a href="#_5">Формальность</a></li>
<li><a href="#static-testing-ampmdash">Статическое тестирование (`Static Testing) &mdash; тип тестирования, при котором код программы не</a></li>
<li><a href="#dynamic-testing">Динамическое  тестирование (Dynamic Testing) — тестирование, при котором выполняется код</a></li>
<li><a href="#functional-testing">Функциональное тестирование (Functional Testing)</a></li>
<li><a href="#non-functional-testing">Нефункциональное тестирование (Non-functional Testing)</a></li>
<li><a href="#testing">Testing</a><ul>
<li><a href="#unit-testing">Unit testing</a></li>
</ul>
</li>
<li><a href="#-">Чек-лист</a><ul>
<li><a href="#_6">Сценарии тестирования удобства использования:</a></li>
<li><a href="#_7">Функциональное тестирование</a><ul>
<li><a href="#_8">Сценарии функционального тестирования:</a></li>
</ul>
</li>
<li><a href="#_9">Тестирование совместимости</a><ul>
<li><a href="#_10">Сценарии тестирования совместимости:</a></li>
</ul>
</li>
<li><a href="#_11">Инструмент для тестирования совместимости</a></li>
<li><a href="#_12">Тестирование баз данных</a><ul>
<li><a href="#_13">Сценарии тестирования баз данных:</a></li>
</ul>
</li>
<li><a href="#_14">Тестирование безопасности</a><ul>
<li><a href="#_15">Сценарии тестирования безопасности:</a></li>
</ul>
</li>
<li><a href="#_16">Тестирование производительности</a><ul>
<li><a href="#_17">Общие тестовые сценарии:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<hr />
<h1 id="_1">Баг</h1>
<p>Что же такое - баг? Ron Patton дает следующее определение загадочному слову <em>software bug</em>:</p>
<ul>
<li>Продукт не делает что-то, что, согласно спецификации (далее - ТЗ), должен делать.</li>
<li>Продукт делает что-то, что, согласно ТЗ, делать не должен.</li>
<li>Продукт делает что-то, что в ТЗ не указано.</li>
<li>Продукт не делает что-то, что в ТЗ не указано, хотя должно.</li>
<li>Продукт очень сложный для понимания, трудный в использовании, медленный, или - глазами тестировщика, 
  который смотрит на продукт как конечный пользователь,  делает что-то... просто не правильно!</li>
</ul>
<p>Начинающие тестировщики часто сосредоточиваются на первых трех пунктах.
Не зная, куда податься, они пытаются по крайней мере убедиться в том, что конечный продукт 
соответствует спецификации.</p>
<p>Очень важным является именно 4 пункт. Фактически этот пункт означает ошибку в ТЗ. А, как все мы 
знаем, ТЗ тоже надо тестировать. На полноту, корректность, осуществимость, необходимость, 
повторяемость и недвусмысленность.</p>
<hr />
<h1 id="istqb">ISTQB</h1>
<p><a name="index_entry_i_1"></a> 
<strong>ISTQB</strong> &mdash; Совет по сертификации тестирования программного обеспечения, действующий на 
международном уровне.</p>
<h2 id="black-box">Метод черного ящика (black box)</h2>
<p>Согласно ISTQB, тестирование черного ящика — это:</p>
<ul>
<li>тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего 
    устройства компонента или системы;</li>
<li>тест-дизайн, основанный на технике черного ящика — процедура написания или выбора тест-кейсов на 
    основе анализа функциональной или нефункциональной спецификации компонента, или системы без знания 
    ее внутреннего устройства.</li>
</ul>
<p>Преимущества:</p>
<ul>
<li>тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и 
    противоречия в спецификации;</li>
<li>тестировщику нет необходимости обладать дополнительными знаниями в программировании; </li>
<li>можно начинать писать тест-кейсы, как только готова спецификация.</li>
</ul>
<p>Недостатки:</p>
<ul>
<li>тестируется только очень ограниченное количество путей выполнения программы;
    без четкой спецификации (а это, скорее, реальность на многих проектах) достаточно трудно составить 
    эффективные тест-кейсы;</li>
<li>некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне 
    модульного тестирования.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Пример</p>
<p>Обычный калькулятор. У нас нет доступа к внутренней системе, но мы можем предположить как 
пользователь будет им пользоваться и на основе этого произвести тестирование функций: отображение 
цифр при нажатии на кнопки, работу операторов(сложение, вычитание и т.д.), удаление результата и т.д.</p>
</div>
<hr />
<h2 id="white-box">Метод белого ящика (white box)</h2>
<p>Тестирование белого ящика ( полный доступ к коду / сам писал код ) — метод тестирования ПО, который 
предполагает, что внутренняя структура/устройство/реализация системы известны тестировщику.
Как правило, таким видом тестирования на проектах занимаются сами программисты, ведь для 
использования этого метода тестировщик должен обладать достаточно высокой квалификацией. </p>
<p>Согласно ISTQB, тестирование белого ящика — это:</p>
<ul>
<li>тестирование, основанное на анализе внутренней структуры компонента или системы;</li>
<li>
<p>тест-дизайн, основанный на технике белого ящика — процедура написания или выбора тест-кейсов на 
 основе анализа внутреннего устройства системы или компонента.
Преимущества:</p>
</li>
<li>
<p>тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского 
    интерфейса;</p>
</li>
<li>можно провести более тщательное тестирование с покрытием большого количества путей выполнения 
    программы.</li>
</ul>
<p>Недостатки:</p>
<ul>
<li>для выполнения тестирования белого ящика необходимо большое количество специальных знаний;</li>
<li>упор делается на код, без учета позиции конечного пользователя, вследствие чего могут пропускаться 
баги.
Пример: двигатель автомобиля. Для водителя (особенно начинающего) двигатель автомобиля - черный ящик. 
Но, для механика нет. Он, словно программист, понимает логику работы компонентов двигателя и знает 
его слабые места.</li>
</ul>
<hr />
<h2 id="grey-box">Метод серого ящика (grey box)</h2>
<p>Тестирование серого ящика ( частичный доступ к коду ) — метод тестирования ПО, который предполагает 
комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно 
лишь частично.</p>
<p>Преимущества:</p>
<ul>
<li>Тестирование серого ящика включает в себя плюсы тестирования «черного» и «белого». Другими словами, 
тестировщик смотрит на объект тестирования с позиции «черного» ящика, но при этом проводит анализ на 
основе тех данных, что он знает о системе;</li>
<li>Тестировщик может проектировать и использовать более сложные сценарии тестирования;
Предоставляет разработчику достаточно времени для исправления дефектов.</li>
</ul>
<p>Недостатки:</p>
<ul>
<li>Возможность анализа кода и тестового покрытия ограничена, так как доступ к исходному коду ограничен.</li>
<li>Тесты могут быть избыточными в том случае, когда разработчик также проверяет свой код Unit-тестами.</li>
</ul>
<p>Пример: разработчик, проверяющий программу, методом черного ящика ИЛИ тестировщик, ознакомившийся с 
архитектурой программы, проверяющий программу, методом черного ящика. Оба понимают логику работы 
программы, но проверяют ее, с точки зрения пользователя. </p>
<hr />
<h1 id="_2">Уровни тестирования</h1>
<p>Выделяют четыре уровня тестирования:</p>
<ul>
<li>Модульное тестирование (Component/Unit testing);</li>
<li>Интеграционное тестирование (Integration testing);</li>
<li>Системное тестирование (System testing);</li>
<li>Приемочное тестирование (Acceptance testing).</li>
</ul>
<p><em>Задачи</em> любого уровня тестирования:</p>
<ul>
<li>Снижение риска;</li>
<li>Обнаружение дефектов;</li>
<li>Предотвращение перехода дефектов на более высокие уровни.</li>
</ul>
<h1 id="_3">Модульное тестирование</h1>
<p>Для обозначения модульного тестирования используется множество синонимичных названий: <code>модульное</code>, 
<code>юнит</code> или <code>компонентное</code>.</p>
<p><em>Модульное</em> тестирование проводится, вызывая код,  и позволяет проверить, что отдельные части общего 
кода работают согласно требованиям документации.
Модульное тестирование, как правило, проводится разработчиками.</p>
<h1 id="_4">Интеграционное тестирование</h1>
<p>Это тестирование взаимодействия модулей системы или нескольких систем.</p>
<p>Так как разные модули приложения могут разрабатываться разными программистами - необходимо проверить 
взаимодействие между ними.
Один компонент (модуль) производит выходные данные, а другой компонент эти данные принимает на вход. 
Проверка правильности взаимодействия этих отдельных модулей или систем и называется <code>интеграционным</code> 
тестированием.
В результате тестирования стоит ожидать, что все смежные системы и модули одной системы должны 
работать согласованно.</p>
<p>Типичные тестовые объекты:</p>
<ul>
<li>Подсистемы;</li>
<li>Базы данных;</li>
<li>Интерфейсы, с помощью которых взаимодействует система;</li>
<li>Микросервисы.</li>
</ul>
<p>Типичные дефекты:</p>
<ul>
<li>Отсутствующие или неправильные данные;</li>
<li>Сбои связи между компонентами;</li>
<li>Нарушение обязательных правил безопасности.</li>
</ul>
<h2 id="system-testing">Системное тестирование (System testing)</h2>
<p>Производится после окончания интеграционного. Сначала разработчики создают и тестируют модули, затем 
интегрируют и тестируют модули между собой. В результате получается некая завершенная система, 
базовая модель приложения.
<em>Цель</em> системного тестирования: проверить все приложение целиком.
На системном уровне тестирования проводится тестирование полного пути (end-to-end/E2E flow)
использования продукта. Под путем использования понимается вся цепочка взаимодействия от запуска 
приложения до какого-то конечного результата.</p>
<p>Пример сценария <strong>end-to-end</strong> для интернет магазина:</p>
<ul>
<li>Незарегистрированный пользователь переходит на сайт интернет магазина;</li>
<li>Регистрируется на сайте;</li>
<li>Авторизуется на сайте;</li>
<li>Находит необходимый товар;</li>
<li>Добавляет его в корзину;</li>
<li>Статус заказа «Ожидает оплаты»;</li>
<li>Оплачивает заказ;</li>
<li>Деньги поступают на счет компании;</li>
<li>Статус заказа меняется на «Оплачен»;</li>
<li>После получения заказа пользователем статус заказа меняется на «Получен».</li>
</ul>
<p>Типичные дефекты:</p>
<ul>
<li>Неожиданное или неверное поведение системы;</li>
<li>Система неспособна выполнять end-to-end задачи;</li>
<li>Система неспособна правильно работать в различных средах;</li>
<li>Система работает не в соответствии с пользовательским руководством.</li>
</ul>
<h2 id="acceptance-testing">Приемочное тестирование (Acceptance testing)</h2>
<p>На текущем уровне тестирования обязательно должны применяться реальные данные и реальное 
использование приложения. Такой подход делает приемочное тестирование очень важным этапом цикла 
выпуска приложения. Это окончательное тестирование, выполняемое после завершения модульного, 
интеграционного и системного тестирования</p>
<p>Критерии приемки — это условия, которым должно удовлетворять приложение, чтобы быть принятыми 
заказчиком.</p>
<p>Приемочное тестирование включает следующие формы:</p>
<ul>
<li>Пользовательское приемочное тестирование (<code>User acceptance testing</code>)  —  производится пользователями 
конечного продукта;</li>
<li>Операционные приемочные испытания (<code>Operational acceptance testing</code>) - как правило, проводят 
системные администраторы. Проверяется функции резервного копирования, установка/ удаление/ 
обновление системы, проверка безопасности и производительности приложения. Необходимо удостовериться, 
что приложение возможно обслуживать и сопровождать на требуемом уровне даже в экстремальных условиях;</li>
<li>Контрактные и нормативные приемочные испытания (<code>Contractual and regulatory acceptance testing</code>)  —<br />
проверка, что приложение соблюдает все нормативные требования, продукт не нарушает чью-то 
интеллектуальную собственность или не использует нелицензионный софт;</li>
<li>Альфа и бета-тестирование (<code>Alpha and beta testing</code> ).</li>
</ul>
<p>Альфа тестирование  включает имитацию реального использования продукта штатными  или сторонними 
разработчиками, либо командой тестировщиков.</p>
<p>Бета-тестирование  —  производится реальными пользователями, с целью получения от них обратной связи 
и выявления максимального числа ошибок для их последующего устранения перед окончательным выходом 
продукта на рынок (релизом).</p>
<hr />
<h1 id="_5">Формальность</h1>
<p>Рассмотрим подходы к тестированию по степени формализации: </p>
<p>1.Тестирование на основе <strong>тест-кейсов</strong>.
    Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых 
    для проверки реализации функционала тестируемого программного обеспечения (ПО) или какого-то его 
    свойства.
    Эта информация включает в себя четкое описание действий, которые нужно выполнить, шаг за шагом. 
    После выполнения действий нужно сравнить ожидаемый результат работы приложения с тем, который 
    получен.
    Это самый распространенный способ тестирования, который также позволяет достичь максимальной 
    полноты исследования продукта за счет строгой систематизации процесса. </p>
<p>2.<strong>Исследовательское тестирование</strong> (<code>Exploratory testing</code>)  <br />
    Exploratory testing — это частично формализованный подход тестирования ПО, при котором тестовые 
    наборы не создаются заранее, а тестировщик проверяет приложение «на лету».
    Тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, 
    дорабатывается в процессе выполнения с целью более полного исследования приложения.
    Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, 
    а не как на бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию 
    ты сначала разрабатываешь тестовые случаи, а затем исполняешь их. Исследовательское тестирование — 
    это одновременный процесс разработки и выполнения тестов.
    В качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться 
    чек-листы.
    Также в результате исследовательского тестирования могут появиться новые тест- кейсы. То есть мы 
    можем выполнять исследовательское тестирование и с целью написания новых тест-кейсов.</p>
<p>3.<strong>Свободное</strong> (<code>интуитивное</code>) тестирование (<code>Ad Hoc Testing</code> или <code>Monkey Testing</code>)
    полностью неформализованный подход, в котором не предполагается использования ни тест-кейсов, ни 
    чек-листов, ни сценариев.</p>
<p>Тестировщик полностью опирается на свою интуицию для спонтанного выполнения с продуктом действий, 
которые, как он считает, могут обнаружить ошибку.</p>
<p>Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует 
придерживаться при выполнении тестирования. Таким образом, метод не структурирован, и, следовательно, 
дефекты, обнаруженные с помощью этого метода, может быть труднее воспроизвести, но и вместе с этим 
возможно найти «Хитрые баги».</p>
<p>В свою очередь <em>Интуитивное тестирование</em> подразделяется на 2 вида:</p>
<p><code>buddy testing</code> (<em>совместное тестирование</em>) — когда 2 человека, как правило разработчик + тестировщик, 
работают параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает 
тестировщику выполнять необходимые проверки, а программисту фиксить баги на ранних этапах.</p>
<p><code>pair testing</code> (<em>парное тестирование</em>) —  когда 2 тестировщика проверяют один модуль и помогают друг 
другу. К примеру, один может искать дефекты, а второй —  их документировать.</p>
<hr />
<h1 id="static-testing-ampmdash">Статическое тестирование (`Static Testing) &mdash; тип тестирования, при котором код программы не</h1>
<p>исполняется во время проведения тестов.</p>
<p>Статическое тестирование включает тестирование спецификации и прочей документации, файлов, либо 
тестирование и анализ программного кода (<code>code review</code>) или скомпилированного кода без его запуска. 
Может производиться как вручную, так и с помощью специальных инструментальных средств, т.е .
автоматизировано.</p>
<p>Код-ревью (<code>code review</code>) может выполняться одним из участников команды разработчиков или 
тестировщиком. Как правило, на код-ревью проверяются качество кода, стандарты использования, решения 
реализации, оставляются комментарии. Это помогает предотвратить дефект на начальном этапе.</p>
<h1 id="dynamic-testing">Динамическое  тестирование (<code>Dynamic Testing</code>) — тестирование, при котором выполняется код</h1>
<p>программы и проверяется поведение приложения во время работы. Тут происходит взаимодействие с 
интерфейсом запущенной программы, ее формами, сервером, базой данных и т.д.</p>
<p>Если проводятся тесты на работающем приложении — значит, это <em>динамические</em> тесты.</p>
<p>При <strong>Ручном тестировании</strong> (<code>Manual Testing</code>) тестировщик выполняет тесты, не используя каких-либо 
средств автоматизации;</p>
<p><strong>Автоматизированное тестирование</strong> (<code>Automation Testing</code>) предполагает использование специального 
программного обеспечения (помимо тестируемого) для контроля выполнения тестов и сравнения ожидаемого 
фактического результата работы программы.</p>
<h1 id="functional-testing">Функциональное тестирование (<code>Functional Testing</code>)</h1>
<p>Оно включает в себя тесты, оценивающие функции приложения. Функции системы — это то, «что» должна 
делать система.</p>
<p>С помощью этого вида приложение проверяется на способность выполнять свои функции. Сюда входят: 
модульное, интеграционное, системное и приемочное тестирование. Кроме того, регрессионное и дымовое 
тестирования тоже являются подвидами функционального. Исполняется функциональное тестирование на 
основании требований в виде спецификаций или пользовательских историй.</p>
<p>По хронологии тестирование разделяют на:</p>
<ul>
<li><em>Дымовое тестирование</em> (<code>Smoke Testing</code>) - включает в себя минимальный набор тестов на самые 
очевидные ошибки. Дымовое тестирование проверяет работоспособность критически важных функциональных 
частей приложения.</li>
</ul>
<p>Например, регистрация нового пользователя, создание нового заказа, выставление счета клиенту, 
получение оплаты. Это базовый функционал, который регулярно контролируется Smoke-тестами.</p>
<ul>
<li><em>Санитарное тестирование</em> (<code>Sanity Testing</code>) — проводится после незначительных изменений в 
функционале, коде или починке багов. Проверяет, что исправленный код или новый функционал работает, 
как и ожидалось.</li>
</ul>
<p>Как пример, программисты устранили дефект на странице создания нового заказа. В этом случае 
санитарные тесты должны проверить общее состояние приложения и нацелены на то, чтобы избежать потерь 
времени и усилий, чтобы быстрее определить возможные недостатки ПО и их критичность, а также стоит 
ли переходить в фазу более тщательного тестирования. Обычно выполняется вручную.</p>
<ul>
<li><em>Регрессионное тестирование</em> (<code>Regression Testing</code>) — тестирование приложения, направленное на 
обнаружение ошибок в уже проверенных участках программ (или исходных кодах). Помогает убедиться, что 
недавние изменения не сломали работающую функциональность приложения. Регрессионные тесты должны 
проводиться при любых изменениях кода, потому полная автоматизация — лучшая практика в этом типе 
тестирования.</li>
</ul>
<p>В регрессию включаются тесты, которые покрывают тестирование безопасности, критических и важных 
функций. Включаются те области, которые часто меняются в ходе разработки, где высока вероятность 
ошибки.</p>
<ul>
<li><em>Повторное тестирование</em> (<code>Retesting</code>) — проводится после устранения дефекта в части функционала с 
целью подтверждения исправления ошибки.  Перепроверяет и подтверждает то, что ранее неудачные 
тест-кейсы успешно проходятся после того, как эти дефекты были исправлены. При этом используются те 
же самые тест-кейсы, которые выявили дефект — с использованием тех же данных, на том же окружении, 
но с различным набором входных данных.</li>
</ul>
<h1 id="non-functional-testing">Нефункциональное тестирование (<code>Non-functional Testing</code>)</h1>
<p><em>Нефункциональное тестирование</em> оценивает характеристики систем и программного обеспечения, такие 
как надежность, производительность, удобство использования, эффективность работы или его 
безопасность. Нефункциональное тестирование — это проверка того, «насколько хорошо» ведет себя 
система.</p>
<ul>
<li>
<p>Тестирование <em>графического интерфейса</em> (<code>User interface testing</code>) — проверка соответствия 
интерфейса ПО требованиям дизайна.</p>
</li>
<li>
<p><em>Пользовательский интерфейс</em> (<code>user interface (UI)</code>) — это интерфейс, который позволяет 
пользователям взаимодействовать  с ПО, используя при этом визуальные индикаторы и графические значки.</p>
</li>
<li>
<p><em>UI-тесты</em> включают в себя проверку наличия всех требуемых элементов на странице, их размеров и 
расположения, тестирование шрифтов, цветов, изображений .</p>
</li>
<li>
<p><em>Тестирование удобства пользования</em> (<code>Usability Testing</code>) — определение удобства использования 
приложения. Проверяется эргономичность интерфейсов. Например, оформление и графические элементы с 
точки зрения удобства восприятия, удобство навигации. В этот вид входит Тестирование доступности.</p>
</li>
<li>
<p><em>Тестирование Доступности</em> (<code>Accessibility Testing</code>) — проверка доступности приложения для людей 
с ограниченными возможностями (пользователям с нарушением слуха, зрения (цветовосприятия), а также 
людях, у которых нет возможности использовать клавиатуру). </p>
</li>
</ul>
<p>Например использование определенной цветовой гаммы, добавление субтитров на видео или озвучивание 
всей страницы.</p>
<ul>
<li>
<p><em>Тестирование производительности</em> (<code>Performance Testing</code>) — тестирование скорости работы 
приложения под определённой нагрузкой.</p>
</li>
<li>
<p><em>Нагрузочное тестирование</em> (<code>Load testing</code>) — данный тип тестирования позволяет оценить поведение 
системы при нормальных условиях и возрастающей нагрузке, целью нагрузочного тестирования является 
также определение максимальной нагрузки, которую может выдержать система.</p>
</li>
</ul>
<p>Например, мы рассчитываем, что одновременно приложением будет пользоваться 500 пользователей, и 
через специальные программы (например <code>Jmeter</code>) создаются условия, которые моделируют использование 
приложения одновременно чуть менее 500 пользователями.</p>
<ul>
<li>
<p><em>Стресс-тестирование</em> (<code>Stress testing</code>) — используется для определения устойчивости системы или 
модуля при пороговых значениях рабочей нагрузки или за ее пределом. К примеру моделируются условия 
одновременного использования 500 или немногим более пользователей.</p>
</li>
<li>
<p><em>Объемное тестирование</em> (<code>Volume testing</code>) — тестирование позволяет оценить производительность 
системы при увеличении объемов данных как самого приложения, так и его базы данных. Когда те же 500 
пользователей отправляют одновременно какой-то объем информации.</p>
</li>
<li>
<p><em>Тестирование надежности</em> (<code>Reliability Testing</code>) — проверка работоспособности приложения при 
длительном тестировании с ожидаемым уровнем нагрузки.</p>
</li>
<li>
<p><em>Тестирование безопасности</em> (<code>Security Testing</code>) — оценка уязвимости приложения к различным атакам. 
Оценка безопасности пользовательских данных, на сколько просто неавторизованный пользователь может 
получить доступ к системе или данных.</p>
</li>
<li>
<p><em>Тестирование Установки</em> (<code>Installation Testing</code>) — проверка успешной инсталляции, настройки, 
обновления и удаления.</p>
</li>
<li>
<p><em>Тестирование совместимости</em> (<code>Compatibility Testing</code>) — проверка корректной работы приложения в 
определенном окружении, например, устройстве, операционной системе (кроссплатформенное тестирование) 
или браузере (кроссбраузерное тестирование).</p>
</li>
<li>
<p><em>Тестирование на отказ и восстановление</em> (<code>Recovery Testing</code>) — проверка насколько хорошо 
приложение может оправиться от аварий и сбоев оборудования.</p>
</li>
<li>
<p><em>Тестирование локализации</em> (<code>Localization Testing</code>) — тестирования локализованной версии 
приложения: проверка правильности перевода интерфейса пользователя, системных сообщений и ошибок, 
раздела "Помощь"/"Справка",  документации, контроль формата даты и времени.</p>
</li>
<li>
<p><em>Тестирование интернационализации</em> (<code>Internationalization Testing</code>) — Насколько продукт может 
адаптироваться для той или иной локали при выходе на другие рынки. Например, возможность поддержки 
вертикального текста Азиатских стран, чтение справа налево в арабских странах.</p>
</li>
</ul>
<hr />
<h1 id="testing">Testing</h1>
<h2 id="unit-testing">Unit testing</h2>
<p>Перед началом тестирования нужно убедиться, что:</p>
<ol>
<li>Код заморожен (обычно релиз-инженеры посылают соответствующий е-мейл);</li>
<li>Версия продукта на внутреннем сайте, на котором вы будете
    производить тестирование, является именно той версией,
    которую вам нужно протестировать.</li>
</ol>
<hr />
<p><a name="index_entry_i_2"></a> </p>
<h1 id="-">Чек-лист</h1>
<p><strong>Чек-лист</strong> (по-русски часто называется <em>контрольным списком</em>) для тестирования веб-приложений 
состоит из:</p>
<ul>
<li>Тестирования удобства использования.</li>
<li>Функционального тестирования.</li>
<li>Тестирования совместимости.</li>
<li>Тестирования баз данных.</li>
<li>Тестирования безопасности.</li>
<li>Тестирования производительности.</li>
<li>Теперь давайте рассмотрим каждый пункт по отдельности.</li>
</ul>
<p><strong>Тестирование удобства использования</strong> &mdash; это тестирование дружелюбности приложения для пользователя.
При тестировании удобства использования проверяется, легко ли новому пользователю разобраться в 
приложении. В целом при тестировании удобства использования тестируется системная навигация.</p>
<p>Тест удобства использования удостоверяется в простоте и эффективности использования продукта при 
использовании стандартных практик тестирования удобства использования.</p>
<h3 id="_6">Сценарии тестирования удобства использования:</h3>
<ul>
<li>Содержание веб-страницы верное, без грамматических и орфографических ошибок.</li>
<li>Все шрифты соответствуют требованиям.</li>
<li>Все тексты правильно выровнены.</li>
<li>Все сообщения об ошибках верные, без орфографических и грамматических ошибок, и соответствуют 
  заголовку окна.</li>
<li>Подсказки существуют для всех полей.</li>
<li>Все поля правильно выровнены.</li>
<li>Между полями, колонками, рядами и сообщениями об ошибках оставлено достаточно свободного места.</li>
<li>Все кнопки должны иметь стандартный формат и размер.</li>
<li>Ссылка на домашнюю страницу должна быть на каждой странице сайта.</li>
<li>Неактивные поля должны быть серыми.</li>
<li>Проверьте, что на сайте нет битых ссылок и изображений.</li>
<li>Подтверждающие сообщения должны отображаться для всех операций обновления и удаления.</li>
<li>Проверьте сайт при разных разрешениях экрана ((640 x 480, 600x800 и т. д.)</li>
<li>Проверьте, что пользователь может пользоваться системой без раздражения.</li>
<li>Проверьте, что TAB правильно работает.</li>
<li>Панель скролла должна появляться только тогда, когда она требуется.</li>
<li>Если при отправке формы есть сообщения об ошибке, в нем должна содержаться информация, переданная 
  пользователем.</li>
<li>Заголовок должен отображаться на каждой странице.</li>
<li>Все поля (текстовые, выпадающие меню, радио-кнопки и т. д.) и кнопки должны быть доступны с 
  клавиатуры, и пользователь должен быть в состоянии пользоваться сайтом, используя только клавиатуру.</li>
<li>Убедитесь, что данные в выпадающих списках не обрезаются из-за размеров поля, и проверьте, зашиты 
  ли данные в код или управляются администратором.</li>
</ul>
<h2 id="_7">Функциональное тестирование</h2>
<p>Тестирование функциональностей и операционного поведения продукта с целью убедиться, что они 
соответствуют спецификациям. Тестирование, игнорирующее внутренние механизмы системы или компонента. 
Оно концентрируется исключительно на выходных данных, полученных в ответ на пользовательский ввод и 
условия исполнения сценариев.</p>
<p>Цель функционального тестирования – убедиться, что ваш продукт соответствует нужной функциональной 
спецификации, упомянутой в вашей документации по разработке.</p>
<h3 id="_8">Сценарии функционального тестирования:</h3>
<ul>
<li>Протестируйте валидацию всех обязательных полей</li>
<li>Убедитесь, что знак звездочки отображается у всех обязательных полей</li>
<li>Убедитесь, что система не отображает окно ошибки при незаполненных необязательных полях.</li>
<li>Убедитесь, что високосные коды корректно валидируются и не вызывают ошибок в расчетах.</li>
<li>Протестируйте числовые поля: они не должны принимать буквы, в этом случае должно отображаться 
  соответствующее сообщение об ошибке.</li>
<li>Протестируйте отрицательные значения в числовых полях, если они разрешены.</li>
<li>Протестируйте, что деление на ноль верно обсчитывается.</li>
<li>Протестируйте максимальную длину каждого поля, чтобы убедиться, что данные не обрезаются.</li>
<li>Протестируйте всплывающее сообщение ("Это поле ограничено 500 знаками"), которое должно 
  отобразиться, если введенные данные превышают разрешенный размер поля.</li>
<li>Убедитесь, что подтверждающее сообщение отображается для операций обновления и удаления.</li>
<li>Убедитесь, что значения стоимости отображаются в нужной валюте.</li>
<li>Протестируйте все поля ввода на спецсимволы.</li>
<li>Протестируйте функциональность тайм-аута.</li>
<li>Протестируйте функциональность сортировки.</li>
<li>Протестируйте функциональность доступных кнопок.</li>
<li>Протестируйте условия использования и часто задаваемые вопросы: они должны быть внятными и 
  доступными пользователю.</li>
<li>Протестируйте, что при отказе функциональности пользователь перенаправляется на специальную 
  страницу ошибки.</li>
<li>Протестируйте, что все загруженные документы правильно открываются.</li>
<li>Протестируйте, что пользователь может скачать загруженные файлы.</li>
<li>Протестируйте почтовую функциональность системы.</li>
<li>Протестируйте, что Java Script верно работает в разных браузерах (IE, Firefox, Chrome, Safari, Opera).</li>
<li>Посмотрите, что будет, если пользователь удалит куки, находясь на сайте.</li>
<li>Посмотрите, что будет, если пользователь удалит куки после посещения сайта.</li>
<li>Протестируйте все данные в выпадающих списках: они должны быть расположены в хронологическом порядке.</li>
</ul>
<h2 id="_9">Тестирование совместимости</h2>
<p>Тестирование совместимости используется, чтобы убедиться, что ваше приложение совместимо с другими 
элементами системы, в которой оно работает – например, браузерами, операционными системами или железом.</p>
<p>Цель тестирования совместимости – оценка того, насколько хорошо ПО работает в определенном браузере, 
под определенной ОС, с другим ПО или железом.</p>
<h3 id="_10">Сценарии тестирования совместимости:</h3>
<ul>
<li>Протестируйте сайт в различных браузерах (IE, Firefox, Chrome, Safari, Opera) и убедитесь, что 
  сайт правильно отображается.</li>
<li>Убедитесь, что используемая версия HTML совместима с соответствующими версиями браузеров.</li>
<li>Убедитесь, что картинки корректно отображаются в разных браузерах.</li>
<li>Убедитесь, что шрифты верно отображаются в разных браузерах.</li>
<li>Убедитесь, что Java Script код работает в разных браузерах.</li>
<li>Проверьте анимированные GIF в разных браузерах.</li>
</ul>
<h2 id="_11">Инструмент для тестирования совместимости</h2>
<p><strong>Spoon.net</strong>: Spoon.net предоставляет доступ к тысячам приложений (браузеров), не требующих 
установки. Этот инструмент помогает вам тестировать приложение в разных браузерах на одной и той же машине.</p>
<h2 id="_12">Тестирование баз данных</h2>
<p>При тестировании баз данных проверяются бэкэнд-записи, введенные через веб или десктоп-приложение. 
Данные, которые отображаются в приложении, должны совпадать с данными, хранящимися в базе данных.
Чтобы тестировать базы данных, тестировщик должен знать следующее:</p>
<ul>
<li>Тестировщик должен понимать функциональные требования, бизнес-логику, основной сценарий приложения 
  и дизайн базы данных.</li>
<li>Тестировщик должен разбираться в таблицах, триггерах, процедурах хранения, способах отображения и 
  указателях, используемых для приложения.</li>
<li>Тестировщик должен понимать логику триггеров, процедур хранения, способов отображения и указателей.</li>
<li>Тестировщик должен понимать, какие таблицы затрагиваются, когда операции вставки, обновления и 
  удаления выполняются в приложении.</li>
<li>Понимая вышеперечисленные пункты, тестировщик может легко написать сценарии для тестирования баз данных.</li>
</ul>
<h3 id="_13">Сценарии тестирования баз данных:</h3>
<ul>
<li>Проверьте название базы данных: оно должно совпадать со спецификацией.</li>
<li>Проверьте таблицы, колонки, типы колонок и значения по умолчанию: все это должно совпадать со 
  спецификацией.</li>
<li>Проверьте, позволяет ли колонка значение null.</li>
<li>Проверьте первичный и внешний ключ каждой таблицы.</li>
<li>Проверьте процедуры хранения.</li>
<li>Протестируйте, установлена ли процедура хранения.</li>
<li>Проверьте название процедуры хранения.</li>
<li>Проверьте названия параметров, их типы и количество.</li>
<li>Проверьте, обязательны параметры или нет.</li>
<li>Проверьте процедуру хранения, удалив некоторые параметры.</li>
<li>Проверьте базу данных, если на выходе ноль – записи с нулем должны быть задействованы.</li>
<li>Проверьте процедуру хранения, задав простые SQL-запросы.</li>
<li>Убедитесь, что процедура возвращает значения.</li>
<li>Проверьте процедуру вводом тестовых данных.</li>
<li>Проверьте поведение каждого флага в таблице.</li>
<li>Убедитесь, что данные правильно сохраняются в базе данных после каждого ввода.</li>
<li>Проверьте данные при каждой операции обновления, удаления и вставки.</li>
<li>Проверьте длину каждого поля. Длина на бэкэнде и фронтэнде должны совпадать.</li>
<li>Проверьте названия баз данных QA, UAT и прода. Имена должны быть уникальными.</li>
<li>Проверьте зашифрованные данные в базе.</li>
<li>Проверьте размер базы и время отклика на каждый запрос.</li>
<li>Проверьте данные, отображающиеся на фронтэнде, и убедитесь, что они совпадают с бэкэндом.</li>
<li>Проверьте целостность данных, вводя невалидные значения в базу.</li>
<li>Проверьте триггеры.</li>
</ul>
<h2 id="_14">Тестирование безопасности</h2>
<p>Тестирование безопасности нацелено на поиск недостатков и пробелов с точки зрения безопасности 
приложения.</p>
<h3 id="_15">Сценарии тестирования безопасности:</h3>
<ul>
<li>Убедитесь, что страницы, содержащие важные данные (пароль, номер кредитной карты, ответы на 
  секретные вопросы и т. п.) открываются через HTTPS (SSL).</li>
<li>Убедитесь, что важная информация (пароль, номер кредитной карты) отображается в зашифрованном виде.</li>
<li>Убедитесь, что правила создания паролей внедрены на всех страницах авторизации (регистрация, 
  страница "забыли пароль", смена пароля).</li>
<li>Убедитесь, что если пароль изменен, пользователь не может зайти под старым.</li>
<li>Убедитесь, что сообщения об ошибках не содержат никакой секретной информации.</li>
<li>Убедитесь, что если пользователь вышел из системы или сессия завершена, он не может пользоваться 
  сайтом.</li>
<li>Проверьте доступ к закрытым и открытым страницам сайта напрямую без авторизации.</li>
<li>Убедитесь, что опция "Просмотр исходного кода" отключена и не видна пользователю.</li>
<li>Убедитесь, что учетная запись пользователя блокируется, если он несколько раз ввел пароль неверно.</li>
<li>Убедитесь, что пароль не хранится в куки.</li>
<li>Убедитесь, что если какая-либо функциональность не работает, система не отображает информацию о 
  приложении, сервере или базе данных. Вместо этого отображается соответствующее сообщение об ошибке.</li>
<li>Проверьте сайт на SQL-инъекции.</li>
<li>Проверьте права пользователей и их роли. К примеру, кандидат не должен быть способен получить 
  доступ к странице администратора.</li>
<li>Убедитесь, что важные операции пишутся в логи, и информацию можно отследить.</li>
<li>Убедитесь, что значения сессий отображаются в адресной строке в зашифрованном виде.</li>
<li>Убедитесь, что куки хранятся в зашифрованном виде.</li>
<li>Проверьте приложение на устойчивость к брутфорс-атакам.</li>
</ul>
<h2 id="_16">Тестирование производительности</h2>
<p>Тестирование производительности проводится для оценки соответствия системы или компонента 
специфичным требованиям к производительности.</p>
<h3 id="_17">Общие тестовые сценарии:</h3>
<ul>
<li>Определение производительности, стабильности и масштабируемости приложения под разной нагрузкой.</li>
<li>Определение, может ли актуальная архитектура поддерживать приложение при пиковых нагрузках.</li>
<li>Определение, какая конфигурация приводит к наилучшим показателям производительности.</li>
<li>Определение бутылочного горла приложения и инфраструктуры.</li>
<li>Определение, не изменилось ли время отклика у новой версии приложения.</li>
<li>Оценка продукта и/или железа с целью удостовериться, что они выдержат прогнозируемые объемы нагрузки.</li>
</ul>
<p>Как проводится тестирование производительности? Вручную или автоматически?</p>
<p>В целом невозможно проводить тестирование производительности вручную по ряду причин:</p>
<ul>
<li>Понадобится большое количество ресурсов.</li>
<li>Невозможно одновременно осуществлять ряд действий.</li>
<li>Отсутствует подходящий способ отслеживания поведения системы.</li>
<li>Сложность выполнения повторяющихся задач.</li>
<li>Чтобы справиться с вышеперечисленными проблемами, используются специальные инструменты 
  тестирования производительности. </li>
</ul>
<p>Ниже перечислены некоторые из них:.</p>
<ul>
<li>Apache JMeter</li>
<li>Load Runner</li>
<li>Borland Silk Performer.</li>
<li>Rational Performance Tester</li>
<li>WAPT</li>
<li>NEO LOAD</li>
</ul>
<p>&nbsp;</p>
<hr />

<p style="margin-top:0px;margin-bottom:0px;text-align:right;"><a href="testing.html" 
title="Previous: Тестирование"><img src="../layout/pict/previous_page.png"/></a>

<a href="artifacts.html" title="Next: Артифакты"><img 
src="../layout/pict/next_page.png"/></a>
</p>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>
</html>
